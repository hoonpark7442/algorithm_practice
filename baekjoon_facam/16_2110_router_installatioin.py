# https://www.acmicpc.net/problem/2110
# 06. 기본 탐색 알고리즘 - 핵심유형 문제풀이
# 문제유형: 이진탐색
# 어떻게 풀어야 할까 - 내 생각

# 집이 5개 공유기 3개 주어지고, 집 좌표는 1,2,8,4,9 라고 하면, 
# 걍... 9-1 에 더하기 1 해서, 이 결과값(9)을 공유기 개수로 나누면 3...
# 최대 3칸씩 두고 놓을 수 있게 되는거 아닌가...

# 이건...이진탐색 문제라한다..

# 문제 풀이 핵심 아이디어
# - 집의 개수 N은 최대 200,000이며 집의 좌표 X는 최대 10억이다. 
# - 이진 탐색을 이용하여 O(N*logX)에 문제를 해결할 수 있다.
# - 가장 인접한 두 공유기 사이의 최대 gap을 이진 탐색으로 찾는다.
# - 데이터가 크면(여기선10억) 일단 이진탐색을 고려해봐야 한다. O(X)라 하더라도 10억이다
# - 그래서 데이터가 크면 일단 logX 복잡도를 문제출제자가 원할거라 생각하면된다.

# - 반복적으로 갭을 설정하며 C개 이상의 공유기를 설치할 수 있는 경우를 찾는다(N=5, C=3)
# - 최대갭 = 8, 최소갭 = 1
# - 이 값들은 이진탐색에서 max, min이 된다.
# - mid값은 (8+1)//2 즉 4이다.
# 1 2 4 8 9 라고 했을 때 4를 갭으로 봤을 때, 1과 8에만 둘 수 있다. 공유기 개수는 3개인데 2개밖에 못놓는다.
# - 이제 최대갭을 바꿔줘야 한다. 아까 4였으니 이젠 4에서 1 뺀 값 3을 최대갭에 넣는다. 최대갭 = 3
# - mid값은 (3+1)//2 즉 2이다.
# (역시나 설명 거지같다.. 갑자기 훅 들어가네...여튼 설명하자면..)
# mid값 2이므로 1 2 4 8 9 라 했을 때 1과4, 8 이렇게 3개 놓을 수 있다. 
# 일단 결과값에 2을 저장한다. 
# 이제 갭을 증가시킨다고 말함(설명 ㄴㄴ). 갑자기 훅치고 들어온다. 이번엔 최소값을 갑자기 3으로 증가시킨다. 아마 최대갭만큼 증가시킨거 같은데
# 머..설명은 없다. 걍 그런거같다...

# 이진탐색은 1. 재귀적 혹은 2. 반복적 으로 문제풀 수 있다. 일반적으로는 반복적으로 푸는게 좀 더 편하다.

# 여기서 왜 갑자기 리스트로 받는지 모르겠다... 
# n, c = list(map(int, input().split(' ')))

# 걍 기존 하던대로 함 해보자
n, c = map(int, input().split())

arr = []

for _ in range(n):
	arr.append(int(input()))

arr = sorted(arr)

min_gap = arr[1] - arr[0]
max_gap = arr[-1] - arr[0]

result = 0

while(min_gap <= max_gap):
	mid = (min_gap + max_gap) // 2 # mid는 갭을 의미한다
	value = arr[0]
	count = 1
	for i in range(1, len(arr)):
		if arr[i] >= value + mid:
			value = arr[i]
			count += 1

	if count >= c: # c개 이상의 공유기 설치할 수 있는 경우
		min_gap = mid + 1
		result = mid
	else:
		max_gap = mid - 1

print(result)

# 5 3
# 1 2 8 4 9












